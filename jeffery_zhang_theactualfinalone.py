# -*- coding: utf-8 -*-
"""Jeffery Zhang - theActualFinalOne

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a5wG0EXWDZnVA5HMPPJ1W1ZvuHfdATb5
"""

from sympy import *
from sympy.abc import t
import math
v_x, v_y, g, r, k_f, h_f = symbols('v_x v_y g r k_f h_f')

gravity = 9.807
radius = 0.11938
y_f = float(input("Vertical distance from hoop (meters): "))
x_f = float(input("Horizontal distance from hoop (meters): "))

def smallest_p(alist):
  min = 100
  for i in alist:
    count = 0
    while i > 1 or i < -1:
      i /= 10
      count += 1
    if count < min: min = count
  return min - 1

def optimal(n, gravity, radius, x_f, y_f, command):
  n1 = expand(n).subs([(g, gravity), (r, radius), (k_f, x_f), (h_f, y_f), (t**2, t)])

  alist = []
  alist += [n1.subs([(t, 0), (sqrt(4*h_f**2 + 4*k_f**2 - 4*r**2), 1)])]
  for i in range(1, 9):
    alist += [expand(n).subs([(t**2, t), (sqrt(g**2*t**2 - 4*g*h_f*t + 4*h_f**2 + 4*k_f**2 - 4*r**2), 1), (g, gravity), (r, radius), (h_f, y_f), (k_f, x_f)]).coeff(t**i)]

  n1 /= 10**smallest_p(alist)
  left_t = 0
  right_t = 50
  while (right_t - left_t) > float(1e-7):
    mid = (left_t + right_t)/2
    if n1.subs(t, mid) > 0:
      right_t = mid
    elif n1.subs(t, mid) < 0:
      left_t = mid
    else:
      left_t = mid
      break
  bestdict = {}
  bestdict["t"] = sqrt(left_t)
  bestdict["vy"] = vyoft.subs([(t, bestdict["t"]), (g, gravity), (r, radius), (k_f, x_f), (h_f, y_f)])
  bestdict["vx"] = vxoft.subs([(t, bestdict["t"]), (g, gravity), (r, radius), (k_f, x_f), (h_f, y_f)])
  bestdict["velocity"] = sqrt(bestdict["vx"]**2 + bestdict["vy"]**2)
  bestdict["angle"] = math.degrees(math.atan(bestdict["vy"]/bestdict["vx"]))
  ans = []
  for i in command:
    ans += [bestdict[i]]
  return ans

def minangle(x_f, y_f):

  eq1 = v_x*t1 + radius*(v_y - gravity*t1)/sqrt(v_x**2 + (v_y - gravity*t1)**2) - x_f
  eq2 = v_y*t1 - 0.5*gravity*t1**2 - radius*v_x/sqrt(v_x**2 + (v_y - gravity*t1)**2) - y_f
  eq3 = v_x*t2 - radius*(v_y - gravity*t2)/sqrt(v_x**2 + (v_y - gravity*t2)**2) - x_f - 0.4572
  eq4 = v_y*t2 - 0.5*gravity*t2**2 + radius*v_x/sqrt(v_x**2 + (v_y - gravity*t2)**2) - y_f

  return nsolve((eq1,eq2,eq3,eq4),(v_x, v_y, t1, t2),(3,3,1.5,1.6))

def shoot(Vx, Vy, x_f, y_f, rad, rim_dia = 0.4572, height = 2):
  import matplotlib.pyplot as plt
  time = 0
  pos_y = 0
  xcoords = []
  ycoords = []
  xp = []
  yp = []
  xm = []
  ym = []
  while pos_y >= 0:
    pos_x = Vx*time
    pos_y = Vy*time - gravity/2*time**2 + 2
    ypvect = rad*sin(atan((Vy - 9.807*time)/Vx) + pi/2)
    xpvect = rad*cos(atan((Vy - 9.807*time)/Vx) + pi/2)
    xcoords.append(pos_x)
    ycoords.append(pos_y)
    xp.append(pos_x + xpvect)
    xm.append(pos_x - xpvect)
    yp.append(pos_y + ypvect)
    ym.append(pos_y - ypvect)
    time += 0.01
  print(xp,'\n',yp)
  plt.plot(xcoords, ycoords, 'r')
  plt.plot(xp, yp, 'k--')
  plt.plot(xm, ym, 'k--')
  plt.plot([x_f, x_f + rim_dia], [y_f + height, y_f + height], 'b')
  plt.xlabel("Horizontal Displacement (m)")
  plt.ylabel("Vertical Displacement (m)")
  plt.grid()

def angletox(n, gravity, radius, y_f, command = ["angle"]):
  import matplotlib.pyplot as plt
  best_angle = []
  x_axis = []
  x_f = 0.5
  while x_f < 14:
    x_axis += [x_f]
    best_angle += [optimal(n, gravity, radius, x_f, y_f, command)]
    x_f += 0.1
  plt.plot(x_axis, best_angle)
  plt.xlabel("Horizontal distance (m)")
  plt.ylabel("Optimal Angle (degrees)")
  plt.grid()

def velocitytox(n, gravity, radius, y_f, command = ['velocity']):
  import matplotlib.pyplot as plt
  best_velocity = []
  x_axis = []
  x_f = 0.5
  while x_f < 14:
    x_axis += [x_f]
    best_velocity += [optimal(n, gravity, radius, x_f, y_f, command)]
    x_f += 0.1
  plt.plot(x_axis, best_velocity)
  plt.xlabel("Horizontal distance (m)")
  plt.ylabel("Optimal velocity (m/s)")
  plt.grid()

vyoft = ((0.5*g*t**2 + h_f)*(g**2*t**4 - 4*g*h_f*t**2 + 4*k_f**2 + 4*h_f**2 - 4*r**2) \
         + 2*r*k_f*sqrt(g**2*t**4 - 4*g*h_f*t**2 + 4*k_f**2 + 4*h_f**2 - 4*r**2) + 4*g*r**2*t**2)\
         /(t*(g**2*t**4 - 4*g*h_f*t**2 + 4*k_f**2 + 4*h_f**2))
vxoft = (k_f*(g**2*t**4 - 4*g*h_f*t**2 + 4*k_f**2 + 4*h_f**2 - 4*r**2) + \
         2*r*(0.5*g*t**2 - h_f)*sqrt(g**2*t**4 - 4*g*h_f*t**2 + 4*k_f**2 + 4*h_f**2 - 4*r**2))\
         /(t*(g**2*t**4 - 4*g*h_f*t**2 + 4*k_f**2 + 4*h_f**2))
v_sq = vxoft**2 + vyoft**2
dv_sq = v_sq.diff(t)
n, d = fraction(together(dv_sq))

vel = optimal(n, gravity, radius, x_f, y_f, ["vx", "vy"])
if vel[0]*(vel[1] + sqrt(vel[1]**2 - 2*gravity*y_f))/gravity > x_f + 0.4572 - radius:
  sol = minangle(x_f, y_f)
else:
  sol = vel

shoot(sol[0], sol[1], x_f, y_f, radius, 0.4572)

angletox(n, gravity, radius, y_f)

velocitytox(n, gravity, radius, y_f)

display(sol)

display(sol[0]**2 + sol[1]**2+"m^2/s^2")

vyoft